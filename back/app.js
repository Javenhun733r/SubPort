import express from 'express';
import authRoutes from './routes/authRoutes.js';
import authorRoutes from './routes/authorRoutes.js';
import chatRoutes from './routes/chatRoutes.js';
import paymentRoutes from './routes/paymentRoutes.js';
import './cron/emailReminder.js';
// import {sendReminders} from "./cron/emailReminder.js";
import cors from 'cors';
import url from 'url';
import { WebSocketServer } from 'ws';
import http from 'http';
import jwt from 'jsonwebtoken';
import prisma from './db/db.config.js';

const app = express();
app.use(cors());
app.use(express.json());
app.use('/', authRoutes);
app.use('/', authorRoutes);
app.use('/', chatRoutes);
app.use('/api', paymentRoutes);
const server = http.createServer(app);
const wss = new WebSocketServer({ server });

const clients = new Map(); // key: WebSocket, value: { chatId, username }
// (async () => {
//     console.log('üöÄ –ü—Ä–∏–º—É—Å–æ–≤–∏–π –∑–∞–ø—É—Å–∫ sendReminders –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è...');
//     try {
//         await sendReminders();
//         console.log('‚úÖ –ü—Ä–∏–º—É—Å–æ–≤–∏–π –∑–∞–ø—É—Å–∫ sendReminders –∑–∞–≤–µ—Ä—à–µ–Ω–æ.');
//     } catch (error) {
//         console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –ø—Ä–∏–º—É—Å–æ–≤–æ–≥–æ –∑–∞–ø—É—Å–∫—É sendReminders:', error);
//     }
//     // –Ø–∫—â–æ –≤–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç–µ Prisma —ñ —Ü–µ–π —Å–∫—Ä–∏–ø—Ç –º–∞—î –∑–∞–≤–µ—Ä—à–∏—Ç–∏—Å—è,
//     // –∞ –Ω–µ –±—É—Ç–∏ —á–∞—Å—Ç–∏–Ω–æ—é –¥–æ–≤–≥–æ—Ç—Ä–∏–≤–∞–ª–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞, –º–æ–∂–ª–∏–≤–æ, –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è prisma.$disconnect();
// })();
wss.on('connection', (ws, req) => {
    const query = url.parse(req.url, true).query;
    const token = query.token;
    let decodedPayload;

    if (token) {
        try {
            decodedPayload = jwt.verify(token, process.env.JWT_SECRET);
        } catch (e) {
            console.error('SERVER: Invalid token on connection:', e.message);
            ws.close(1008, "Invalid or expired token");
            return;
        }
    } else {
        ws.close(1008, "Token not provided");
        return;
    }

    const username = decodedPayload.name || 'Anonymous';
    const userId = Number(decodedPayload.id); // –ó–∞–≤–∂–¥–∏ —á–∏—Å–ª–æ

    if (!userId || isNaN(userId)) {
        console.error('SERVER: Token does not contain valid numeric userId');
        ws.close(1008, "Invalid token payload");
        return;
    }

    clients.set(ws, { chatId: null, username, userId });
    console.log(`SERVER: Client connected: ${username} (ID: ${userId})`);

    ws.on('message', async (data) => {
        let msgFromClient;
        try {
            msgFromClient = JSON.parse(data);
        } catch (e) {
            console.error('SERVER: Invalid JSON received:', data, e);
            ws.send(JSON.stringify({ type: 'error', message: 'Invalid JSON format.' }));
            return;
        }

        const senderInfo = clients.get(ws);
        if (!senderInfo) {
            console.error('SERVER: Message from an untracked client.');
            return;
        }
        console.log(`SERVER: Msg type '${msgFromClient.type}' from ${senderInfo.username}`, msgFromClient);


        switch (msgFromClient.type) {
            case 'join': {
                const rawChatId = msgFromClient.chatId;
                const numericChatId = rawChatId != null ? Number(rawChatId) : null;

                if (numericChatId != null && !isNaN(numericChatId)) {
                    senderInfo.chatId = numericChatId;
                    clients.set(ws, senderInfo);
                    console.log(`SERVER: Client ${senderInfo.username} (ID: ${senderInfo.userId}) joined chat ${numericChatId}`);
                    await broadcastUsersInChat(numericChatId); // –í–∏–∫–ª–∏–∫–∞—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω—É —Ñ—É–Ω–∫—Ü—ñ—é
                } else {
                    console.warn(`SERVER: Client ${senderInfo.username} sent join with invalid chatId: ${rawChatId}`);
                }
                break;
            }
            case 'newChatMessage': {
                const { chatId: rawChatId, text, messageType, fileUrl, fileName, fileType, fileSize } = msgFromClient;
                const currentChatId = Number(rawChatId);
                const currentSenderId = senderInfo.userId;
                const currentFileSize = fileSize != null ? parseInt(fileSize) : null;

                if (isNaN(currentChatId)) {
                    console.error(`SERVER: Invalid chatId for newChatMessage: ${rawChatId}`);
                    ws.send(JSON.stringify({ type: 'error', message: 'Invalid chatId.' }));
                    return;
                }
                try {
                    const savedDbMessage = await prisma.message.create({ // –í–∞—à —ñ—Å–Ω—É—é—á–∏–π –∫–æ–¥ –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
                        data: {
                            text: text || null,
                            messageType: messageType || 'text',
                            fileUrl: fileUrl || null,
                            fileName: fileName || null,
                            fileType: fileType || null,
                            fileSize: currentFileSize,
                            createdAt: new Date(),
                            chat: { connect: { id: currentChatId } },
                            sender: { connect: { id: currentSenderId } }
                        },
                        select: { /* ... –≤–∞—à select ... */
                            id: true, text: true, createdAt: true, messageType: true,
                            fileUrl: true, fileName: true, fileType: true, fileSize: true,
                            chat: { select: { id: true } },
                            sender: { select: { id: true, name: true } }
                        }
                    });
                    const messageToBroadcast = { /* ... –≤–∞—à messageToBroadcast ... */
                        type: 'chatMessage', id: savedDbMessage.id, text: savedDbMessage.text,
                        chatId: savedDbMessage.chat.id, author: savedDbMessage.sender.name,
                        authorId: savedDbMessage.sender.id, timestamp: savedDbMessage.createdAt.toISOString(),
                        messageType: savedDbMessage.messageType, fileUrl: savedDbMessage.fileUrl,
                        fileName: savedDbMessage.fileName, fileType: savedDbMessage.fileType,
                        fileSize: savedDbMessage.fileSize
                    };
                    for (const [clientWs, clientData] of clients.entries()) {
                        if (clientWs.readyState === WebSocket.OPEN && clientData.chatId === currentChatId) {
                            clientWs.send(JSON.stringify(messageToBroadcast));
                        }
                    }
                } catch (error) {
                    console.error('SERVER: Error saving/broadcasting newChatMessage:', error);
                    ws.send(JSON.stringify({ type: 'error', message: 'Could not process your message.' }));
                }
                break;
            }
            case 'userStartedTyping': { // –í–∞—à —ñ—Å–Ω—É—é—á–∏–π –æ–±—Ä–æ–±–Ω–∏–∫
                const { chatId: rawChatId } = msgFromClient;
                const numericChatId = Number(rawChatId);
                if (!isNaN(numericChatId) && senderInfo) {
                    const payload = { type: 'userTyping', chatId: numericChatId, userId: senderInfo.userId, username: senderInfo.username, isTyping: true };
                    for (const [clientWs, clientData] of clients.entries()) {
                        if (clientWs !== ws && clientWs.readyState === WebSocket.OPEN && clientData.chatId === numericChatId) {
                            clientWs.send(JSON.stringify(payload));
                        }
                    }
                }
                break;
            }
            case 'userStoppedTyping': { // –í–∞—à —ñ—Å–Ω—É—é—á–∏–π –æ–±—Ä–æ–±–Ω–∏–∫
                const { chatId: rawChatId } = msgFromClient;
                const numericChatId = Number(rawChatId);
                if (!isNaN(numericChatId) && senderInfo) {
                    const payload = { type: 'userTyping', chatId: numericChatId, userId: senderInfo.userId, username: senderInfo.username, isTyping: false };
                    for (const [clientWs, clientData] of clients.entries()) {
                        if (clientWs !== ws && clientWs.readyState === WebSocket.OPEN && clientData.chatId === numericChatId) {
                            clientWs.send(JSON.stringify(payload));
                        }
                    }
                }
                break;
            }
            default:
                console.log(`SERVER: Received unknown message type: '${msgFromClient.type}' from user ${senderInfo.username}.`);
                ws.send(JSON.stringify({ type: 'error', message: `Unknown message type: ${msgFromClient.type}`}));
        }
    });

    ws.on('close', async (code, reason) => { // –ó—Ä–æ–±–ª–µ–Ω–æ async
        const clientInfo = clients.get(ws);
        if (clientInfo) {
            console.log(`SERVER: Client ${clientInfo.username} (ID: ${clientInfo.userId}) disconnected. Code: ${code}`);
            const chatId = clientInfo.chatId; // chatId –≤–∂–µ –º–∞—î –±—É—Ç–∏ —á–∏—Å–ª–æ–º
            clients.delete(ws);
            if (chatId != null) {
                await broadcastUsersInChat(chatId); // –û–Ω–æ–≤–∏—Ç–∏ —Å–ø–∏—Å–æ–∫ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –¥–ª—è —Ä–µ—à—Ç–∏
            }
        } else {
            console.log(`SERVER: An untracked client disconnected.`);
        }
    });

    ws.on('error', (err) => {
        const clientInfo = clients.get(ws);
        console.error(`SERVER: WebSocket error for ${clientInfo ? clientInfo.username : 'unknown client'}:`, err);
    });
});

async function broadcastUsersInChat(chatIdToBroadcast) { // chatIdToBroadcast –º–∞—î –±—É—Ç–∏ —á–∏—Å–ª–æ–º
    if (chatIdToBroadcast == null) {
        console.warn("SERVER: broadcastUsersInChat called with null chatId.");
        return;
    }
    const numericChatId = Number(chatIdToBroadcast);

    try {
        // 1. –û—Ç—Ä–∏–º–∞—Ç–∏ –≤—Å—ñ—Ö –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–∏—Ö —É—á–∞—Å–Ω–∏–∫—ñ–≤ —á–∞—Ç—É –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
        const dbParticipants = await prisma.chatUser.findMany({
            where: { chatId: numericChatId },
            include: {
                user: { // –í–∫–ª—é—á–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
                    select: {
                        id: true,
                        name: true
                    }
                }
            }
        });

        // 2. –°—Ç–≤–æ—Ä–∏—Ç–∏ —Å–ø–∏—Å–æ–∫ —É—Å—ñ—Ö —É—á–∞—Å–Ω–∏–∫—ñ–≤ –∑ —ó—Ö –æ–Ω–ª–∞–π–Ω-—Å—Ç–∞—Ç—É—Å–æ–º
        const allUsersWithStatus = dbParticipants.map(participant => {
            const dbUser = participant.user;
            let isUserOnlineInThisChat = false;

            // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —á–∏ —Ü–µ–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á —î —Å–µ—Ä–µ–¥ –∞–∫—Ç–∏–≤–Ω–∏—Ö WebSocket –∫–ª—ñ—î–Ω—Ç—ñ–≤
            // —ñ —á–∏ –≤—ñ–Ω –ø—Ä–∏—î–¥–Ω–∞–Ω–∏–π –¥–æ –ø–æ—Ç–æ—á–Ω–æ–≥–æ —á–∞—Ç—É.
            for (const clientData of clients.values()) {
                if (clientData.userId === dbUser.id && clientData.chatId === numericChatId) {
                    isUserOnlineInThisChat = true;
                    break;
                }
            }
            return {
                userId: dbUser.id,
                username: dbUser.name || `User ${dbUser.id}`, // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —ñ–º'—è –∞–±–æ ID
                isOnline: isUserOnlineInThisChat
            };
        });

        const payload = JSON.stringify({
            type: 'usersInChat',
            chatId: numericChatId,
            users: allUsersWithStatus
        });

        console.log(`SERVER: Broadcasting usersInChat for chat ${numericChatId}. Total mapped users: ${allUsersWithStatus.length}`);

        // 3. –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ —Ü–µ–π –ø–æ–≤–Ω–∏–π —Å–ø–∏—Å–æ–∫ –≤—Å—ñ–º –∫–ª—ñ—î–Ω—Ç–∞–º, —è–∫—ñ –∑–∞—Ä–∞–∑ —É —Ü—å–æ–º—É —á–∞—Ç—ñ
        for (const [clientWs, clientData] of clients.entries()) {
            if (clientData.chatId === numericChatId && clientWs.readyState === WebSocket.OPEN) {
                clientWs.send(payload);
            }
        }
    } catch (error) {
        console.error(`SERVER: Error in broadcastUsersInChat for chat ${numericChatId}:`, error);
    }
}
const port = process.env.PORT || 8081;
server.listen(port, () => console.log(`Listening on port ${port}`));
export default app;
